// Benchmark boilerplate generated by Benchmark

import Benchmark
import Foundation
import KeyValueStorage

func benchmarks() {
     let keysSeed: [String] = [
        "abc",
        "abb",
        "cba",
        "aaa",
        "bba",
        "bab",
        "cca"
    ]

    let keysCountSteps = [1_000, 10_000, 100_000, 1_000_000]
    let basicConfig = Benchmark.Configuration(metrics: [.wallClock], timeUnits: .milliseconds, scalingFactor: .one, maxIterations: 1)
    let fetchConfig = Benchmark.Configuration(metrics: [.wallClock, .peakMemoryResident], timeUnits: .milliseconds, scalingFactor: .one, maxIterations: 1)

    func makeTestKeys(count: Int) -> [String] {
        return (0..<count)
            .map { _ in
                (0..<Int.random(in: 1..<30))
                    .map { _ in keysSeed.randomElement()! }
                    .joined()
            }
    }

    func makeStorage(_ index: StorageConfiguration.IndexImplementation, prefillWith keys: [String] = []) async -> KeyValueStorage {
        let storage = StorageProvider.storage(configuration: .inMemory(indexImplementation: index))

        for key in keys {
            try! await storage.put(Int.random(in: 0..<100), forKey: key)
        }

        return storage
    }
    
    // 8 * million keys at max take about 8GB RAM
    for keyCount in keysCountSteps {
        let keysToPopulate = makeTestKeys(count: keyCount)
         // Every third key do not exist (using letter that is not in seed)
        let keysToFetch = (0..<keyCount).map { 
            let key = keysToPopulate.randomElement()! 
            return $0 % 3 == 0 ? key + "d" : key 
        }

        let prefixesToFetch = makeTestKeys(count: 1000)

        // Benchmark(
        //     "Radix#insert#\(keyCount)#",
        //     configuration: basicConfig
        // ) { (benchmark: Benchmark, storage: KeyValueStorage) in
        //     for key in keysToPopulate {
        //         try! await storage.put(Int.random(in: 0..<100), forKey: key)
        //     }
        // } setup: {
        //      await makeStorage(.radix)
        // }

        // Benchmark(
        //     "Set#insert#\(keyCount)#",
        //     configuration: basicConfig
        // ) { (benchmark: Benchmark, storage: KeyValueStorage) in
        //     for key in keysToPopulate {
        //         try! await storage.put(Int.random(in: 0..<100), forKey: key)
        //     }
        // } setup: {
        //     await makeStorage(.set)
        // }

        // // NOTE: Index is not used, so testing only radix
        // Benchmark(
        //     "Radix#Get_by_key#\(keyCount)#",
        //     configuration: basicConfig
        // ) { (benchmark: Benchmark, storage: KeyValueStorage) in
        //     for key in keysToFetch {
        //         blackHole(await storage.get(forKey: key))
        //     }
        // } setup: {
        //     await makeStorage(.radix, prefillWith: keysToPopulate)
        // }

        // Benchmark(
        //     "Radix#get_random#\(keyCount)#",
        //     configuration: basicConfig
        // ) { (benchmark: Benchmark, storage: KeyValueStorage) in
        //     for _ in (0..<keyCount) {
        //         blackHole(await storage.getRandomValue())
        //     }
        // } setup: {
        //     await makeStorage(.radix, prefillWith: keysToPopulate)
        // }

        // Benchmark(
        //     "Set#get_random#\(keyCount)#",
        //     configuration: basicConfig
        // ) { (benchmark: Benchmark, storage: KeyValueStorage) in
        //     for _ in (0..<keyCount) {
        //         blackHole(await storage.getRandomValue())
        //     }
        // } setup: {
        //     await makeStorage(.set, prefillWith: keysToPopulate)
        // }

        Benchmark(
            "Radix#keys_by_prefix#\(keyCount)#",
            configuration: fetchConfig
        ) { (benchmark: Benchmark, storage: KeyValueStorage) in
            for prefix in prefixesToFetch {
                 blackHole(await storage.keys(withPrefix: prefix))
            }
        } setup: {
            await makeStorage(.radix, prefillWith: keysToPopulate)
        }

        Benchmark(
            "Set#keys_by_prefix#\(keyCount)#",
            configuration: fetchConfig
        ) { (benchmark: Benchmark, storage: KeyValueStorage) in
            for prefix in prefixesToFetch {
                blackHole(await storage.keys(withPrefix: prefix))
            }
        } setup: {
            await makeStorage(.set, prefillWith: keysToPopulate)
        }
    }
}
